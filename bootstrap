#!/bin/bash
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2025, John Unland
# SPDX-FileCopyrightText: 2014-2022, Matias Andres Fonzo <selk@dragora.org>

# EXIT STATUS
# 0 = Successful completion
# 1 = Minor common errors (e.g: help usage, support not available)
# 2 = Command execution error
# 3 = Integrity check error for compressed files

PROGRAM="${0##*/}"

# Override locale settings
LC_ALL=POSIX
LANGUAGE=POSIX
export LC_ALL LANGUAGE

# Get physical working (absolute path) and utilities directory
worktree="$(CDPATH='' cd -P -- "$(dirname -- "$0")" && pwd -P)" || exit $?
worktree_utils="${worktree}/utils"

### Functions

usage() {
    printf '%s' \
        "Usage: $PROGRAM [OPTIONS] [FILE]...
Builder of custom stages (cross compilers, GNU/Linux distributions).

Where FILE is any shell script (as long as it is executable) from
a stage number.  Without FILE, it loads all the found scripts from
the stage number.  Stage numbers come from the stages directory
(${worktree}/stages).

Defaults for the options are specified in brackets.

Options:
  -a          Target architecture [${arch}]
  -j          Parallel jobs for the compiler [${jobs}]
  -k          Keep (don't delete) source directory
  -o          Output directory [${output}]
  -s          Stage number to build [${stage}]
  -h          Display this help and exit
  -V          Print version information and exit

Some influential environment variables:
  TMPDIR      Temporary directory for sources [${TMPDIR}]
  BTCC        C compiler command [${BTCC}]
  BTCXX       C++ compiler command [${BTCXX}]
  BTCFLAGS    C compiler flags [${BTCFLAGS}]
  BTCXXFLAGS  C++ compiler flags [${BTCXXFLAGS}]
  BTCPPFLAGS  Preprocessor flags [${BTCPPFLAGS}]
  BTLDFLAGS   Linker flags [${BTLDFLAGS}]
  VENDOR      Vendor name to reflect on the target triplet

Available targets from ${worktree}/targets ...

"
    for name in "${worktree}/targets"/*; do
        sed -e '2q;d' "$name"
    done
    unset -v name
    echo ""
}

version() {
    printf '%s' \
        "$PROGRAM 1.00
Copyright (C) 2024-2025 John Unland.
Copyright (C) 2014-2022 Matias Andres Fonzo.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
"
}

warn() {
    printf '%s\n' "$@" 1>&2
}

chkstatus_or_exit() {
    status=$?

    if test $status -ne 0; then
        # Run the demount_chroot function if the stage is set to 2
        if test "$stage" = 2; then
            demount_chroot
        fi

        echo "Return status = $status" 1>&2
        exit "${1-2}" # If not given, defaults to 2
    fi

    unset -v status
}

mount_chroot() {
    # Mount the required filesystems for chroot
    warn "Mounting chroot environment ..."

    mount -v --bind /dev "$LFS/dev"
    mount -vt devpts devpts -o gid=5,mode=0620 "$LFS/dev/pts" 
    mount -vt proc proc "$LFS/proc"
    mount -vt sysfs sysfs "$LFS/sys"
    mount -vt tmpfs tmpfs "$LFS/run"

    # Mount sources directory
    mount -v --bind "$LFS/var/local/build/sources" "$LFS/var/local/build"

    if [ -h $LFS/dev/shm ]; then
      install -v -d -m 1777 $LFS$(realpath /dev/shm)
    else
      mount -vt tmpfs -o nosuid,nodev tmpfs $LFS/dev/shm
    fi
}

demount_chroot() {
    warn "Demounting chroot environment ..."
    # Define the required mount points
    mount_points=("$LFS/dev/pts" "$LFS/dev/shm" "$LFS/dev" "$LFS/run" "$LFS/proc" "$LFS/sys" "$LFS/var/local/build")

    # Make sure we dont have any left over mounts
    for point in "${mount_points[@]}"; do
        if mountpoint -q "$point"; then
            echo "Unmounting $point ..."
            if ! umount "$point"; then
                warn "Failed to unmount $point doing a lazy unmount ..."
                umount -l "$point"
            fi
        else
            echo "$point is not mounted."
        fi
    done
}

# Just a function alias to unpack files
unpack() {
    ${worktree_utils}/unpack-files "$@" || chkstatus_or_exit
}

# Print a warning for good practices.
#
# Recommended practices is to set variables
# in front of `configure' or make(1), see:
#
# http://www.gnu.org/software/make/manual/html_node/Environment.html
# http://gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/Defining-Variables.html
# http://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/Setting-Output-Variables.html
warn_flags() {
    warn "" \
        "WARNING: Environment variable '$1' is set." \
        "This will be unset to avoid possible risks." \
        ""
    sleep 3
}

### Default values
BTCC="${BTCC:=gcc}"
BTCXX="${BTCXX:=g++}"
BTCFLAGS="${BTCFLAGS:=-O2}"
BTCXXFLAGS="${BTCFLAGS:=-O2}"
BTCPPFLAGS="${BTCPPFLAGS:=-P}"
BTLDFLAGS="${BTLDFLAGS:=}"
opt_keep=opt_keep.off
stage=0
arch="$(uname -m)" || chkstatus_or_exit
jobs=8
output="${worktree}/OUTPUT.${PROGRAM}"
TMPDIR="${TMPDIR:=${output}/sources}"
VENDOR="${VENDOR:=lfs}"

# Compose vendor name adding "-" as suffix
test -n "$VENDOR" && VENDOR="${VENDOR}-"

# Make sure unpack-files script is available
if test ! -x "${worktree_utils}/unpack-files"; then
    warn "${PROGRAM}: Required script 'unpack-files' not found"
    exit 1
fi

### Parse options
while getopts :ha:j:ko:s:V name; do
    case $name in
        h)
            usage
            exit 0
            ;;
        a)
            arch="$OPTARG"
            ;;
        j)
            jobs="$OPTARG"
            ;;
        k)
            opt_keep=opt_keep
            ;;
        o)
            output="$OPTARG"
            ;;
        s)
            stage="$OPTARG"
            ;;
        V)
            version
            exit 0
            ;;
        :)
            warn "Option '-${OPTARG}' requires an argument"
            usage
            exit 1
            ;;
        \?)
            warn "Illegal option -- '-${OPTARG}'"
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))
unset -f usage version

# Check for environment variables, print warning, unset in any case
test -n "$CC" && warn_flags CC
test -n "$CXX" && warn_flags CXX
test -n "$CFLAGS" && warn_flags CFLAGS
test -n "$CXXFLAGS" && warn_flags CXXFLAGS
test -n "$CPPFLAGS" && warn_flags CPPFLAGS
test -n "$LDFLAGS" && warn_flags LDFLAGS
unset CC CXX CFLAGS CXXFLAGS CPPFLAGS LDFLAGS warn_flags

# Load target architecture-file
if test -f "${worktree}/targets/$arch"; then
    echo "${PROGRAM}: Loading target $arch ..."
    . "${worktree}/targets/$arch"
else
    warn \
        "${PROGRAM}: Target name not recognized -- '${arch}'" \
        "See '$0 -h' for more information"
    exit 1
fi

# Set host variable if MACHTYPE is defined
if test -n "$MACHTYPE"; then
    host="$MACHTYPE"
fi

# Adjust 'host' for cross-compilation by renaming or appending to the VENDOR field
if test "$host" = "$target"; then
    # Rename VENDOR to 'cross'.  If empty, 'cross-linux' is added
    case "${host%-*-*}" in
        *-*)
            host="$(echo "$host" | sed -e 's/-[^-]*/-cross/')"
            ;;
        *)
            host="$(echo "$host" | sed -e 's/-[^-]*/-cross-linux/')"
            ;;
    esac
fi

# Compose variables for the physical output,
# printing some useful information
LFS="$output/${target}-sysroot"
LFS_TGT="$target"
LFS_HOST="$host"

# Print some useful information
printf '%s\n' \
    "BTCC: $BTCC" \
    "BTCXX: $BTCXX" \
    "BTCFLAGS: $BTCFLAGS" \
    "BTCXXFLAGS: $BTCXXFLAGS" \
    "BTLDFLAGS: $BTLDFLAGS" \
    "CPPFLAGS: $BTCPPFLAGS" \
    "Host: $host" \
    "Target: $target" \
    "Output directory: $output" \
    "LFS directory: $LFS"

# Remove write permission for group and other
umask 022

# Create required directories
mkdir -p -- "$output" "$TMPDIR"
chkstatus_or_exit

# Set default PATH, propagate variables
PATH="${LFS}/tools/bin:${PATH}"
CONFIG_SITE=$LFS/usr/share/config.site

export PATH VENDOR TMPDIR CONFIG_SITE

# Main loop
for file in ${worktree}/stages/${stage}/${@:-??-*}; do
    file="${file##*/}"
    done_file=".stage-${stage}-${file}.done"

    if test ! -f "${worktree}/stages/${stage}/$file"; then
        warn "${PROGRAM}: ${stage}/${file}: No such file or stage number"
        exit 1
    fi
    if test ! -x "${worktree}/stages/${stage}/$file"; then
        warn "${PROGRAM}: ${stage}/${file}: File not executable, dodging"
        continue
    fi

    ### Stage pre-settings

    # Create pre-settings for stage 0
    if test "$stage" = 0; then
        echo "Running pre-settings..."
    fi

    # Create pre-settings for stage 1
    if test "$stage" = 1; then
        echo "Running pre-settings..."
    fi

    # Create pre-settings for stage 2
    if test "$stage" = 2; then
        echo "Running pre-settings..."

        # Verify that to run this stage we must be root.
        if test "$(id -u)" -ne 0; then
            warn "${PROGRAM}: You must be root to run this stage"
            exit 1
        fi

        # Create needed directories if not already created
        mkdir -pv "$LFS"/{dev,proc,sys,run,var/local/build/sources}

        # Check if unpack-files script is available to the chroot environment
        if ! test -f "$LFS/usr/bin/unpack-files"; then
            install -v -m 755 "${worktree_utils}/unpack-files" "$LFS/usr/bin"
            ln -sv unpack-files "$LFS/usr/bin/unpack"
        fi

        # Copy sources to the chroot environment
        #cp -rv "${worktree}/sources" "$LFS/var/local/build"

        # Setup permissions for the chroot environment
        chown -R root:root "$LFS"

        demount_chroot || chkstatus_or_exit

        mount_chroot || chkstatus_or_exit
    fi

    # Check if the done file exists
    if test -f "${output}/${done_file}"; then
        echo "${PROGRAM}: Skipping $file from stages/${stage} ..."
        rm -rf "${TMPDIR}"/* || chkstatus_or_exit
        continue
    fi

    echo "${PROGRAM}: Processing $file from stages/${stage} ..."

    # Set trap before to run the script in order to
    # catch the return status, exit code 2 if fails
    trap 'chkstatus_or_exit 2' EXIT HUP INT QUIT ABRT TERM

    # Activate shell option(s)
    set -e +h

    # Clear hash table
    hash -r >/dev/null 2>&1 || true

    # If we are running stage 2, we need to run the scripts in a chroot
    if test "$stage" = 2; then
        # Pass in the stage2 scripts into bash with the chroot command
        chroot "$LFS" /usr/bin/env -i \
            HOME="/var/local/build" \
            TERM="$TERM" \
            LC_ALL=POSIX \
            MAKEFLAGS="-j${jobs}" \
            PS1='(chroot)$ ' \
            PATH=/bin:/usr/bin:/sbin:/usr/sbin \
            MAKEFLAGS="-j$(nproc)" \
            TESTSUITEFLAGS="-j$(nproc)" \
            BTCFLAGS="$BTCFLAGS" \
            BTCXXFLAGS="$BTCXXFLAGS" \
            BTCPPFLAGS="$BTCPPFLAGS" \
            BTLDFLAGS="$BTLDFLAGS" \
            BTCC="$BTCC" \
            BTCXX="$BTCXX" \
            target="$target" \
            arch="$arch" \
            worktree="/var/local/build" \
            sources_dir="/var/local/build/sources" \
            /bin/bash -e < "${worktree}/stages/${stage}/$file" 

        # Get the return status of the chroot command
        CHROOT_STATUS=$?

        # Make sure we are in the worktree directory
        cd -- "$worktree" || chkstatus_or_exit

        # Unmount the chroot environment
        demount_chroot

        # Exit if the chroot command failed
        if test $CHROOT_STATUS -ne 0; then
            echo "${PROGRAM}: Chroot command failed with status $CHROOT_STATUS"
            exit 2
        fi
    else
       # Set pipefail to catch errors in the pipe
        set -o pipefail

        # Run the scripts as usual and log the output to a file
        . "${worktree}/stages/${stage}/$file" | tee "${output}/${file}.log"

        # Disable pipefail
        set +o pipefail
    fi

    # Deactivate shell option(s)
    set +e -h

    # Clear hash table
    hash -r >/dev/null 2>&1 || true

    # Reset given signals
    trap - EXIT HUP INT QUIT ABRT TERM

    # Create the done file
    echo "${PROGRAM}: Done processing $file from stages/${stage} ..."
    echo "${PROGRAM}: Marking with done file: ${done_file}"
    touch "${output}/${done_file}"

    # Delete declared directories on the cleanup() function
    if test "$opt_keep" != opt_keep; then
        if type cleanup 1>/dev/null 2>/dev/null; then
            cleanup
            chkstatus_or_exit 2
            unset -f cleanup
        fi
    fi

    # Back to the current working directory
    cd -- "$worktree" || chkstatus_or_exit
done
