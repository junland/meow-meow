#!/bin/bash
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2025, John Unland
# SPDX-FileCopyrightText: 2014-2022, Matias Andres Fonzo <selk@dragora.org>

# EXIT STATUS
# 0 = Successful completion
# 1 = Minor common errors (e.g: help usage, support not available)
# 2 = Command execution error
# 3 = Integrity check error for compressed files

PROGRAM="${0##*/}"

# Override locale settings
LC_ALL=POSIX
LANGUAGE=POSIX
export LC_ALL LANGUAGE

# Get physical working (absolute path) and utilities directory
worktree="$(CDPATH='' cd -P -- "$(dirname -- "$0")" && pwd -P)" || exit $?
worktree_utils="${worktree}/utils"

### Functions

usage() {
    printf '%s' \
        "Usage: $PROGRAM [OPTIONS] [FILE]...
Builder of custom stages (cross compilers, GNU/Linux distributions).

Where FILE is any shell script (as long as it is executable) from
a stage number.  Without FILE, it loads all the found scripts from
the stage number.  Stage numbers come from the stages directory
(${worktree}/stages).

Defaults for the options are specified in brackets.

Options:
  -a          Target architecture [${arch}]
  -j          Parallel jobs for the compiler [${jobs}]
  -k          Keep (don't delete) source directory
  -o          Output directory [${output}]
  -s          Stage number to build [${stage}]
  -h          Display this help and exit
  -V          Print version information and exit

Some influential environment variables:
  TMPDIR      Temporary directory for sources [${TMPDIR}]
  BTCC        C compiler command [${BTCC}]
  BTCXX       C++ compiler command [${BTCXX}]
  BTCFLAGS    C compiler flags [${BTCFLAGS}]
  BTCXXFLAGS  C++ compiler flags [${BTCXXFLAGS}]
  BTCPPFLAGS  Preprocessor flags [${BTCPPFLAGS}]
  BTLDFLAGS   Linker flags [${BTLDFLAGS}]
  VENDOR      Vendor name to reflect on the target triplet

Available targets from ${worktree}/targets ...

"
    for name in "${worktree}/targets"/*; do
        sed -e '2q;d' "$name"
    done
    unset -v name
    echo ""
}

version() {
    printf '%s' \
        "$PROGRAM 1.00
Copyright (C) 2024-2025 John Unland.
Copyright (C) 2014-2022 Matias Andres Fonzo.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
"
}

warn() {
    printf '%s\n' "$@" 1>&2
}

chkstatus_or_exit() {
    status=$?

    if test $status -ne 0; then
        echo "Return status = $status" 1>&2
        exit "${1-2}" # If not given, defaults to 2
    fi

    unset -v status
}

# unmount the chroot environment
demount() {
    warn "Demounting chroot environment ..."
    # Define the required mount points
    mount_points=(
        "$LFS/proc"
        "$LFS/dev/pts"
        "$LFS/dev"
        "$LFS/sys"
        "$LFS/run"
    )

    # Make sure we dont have any left over mounts
    for point in "${mount_points[@]}"; do
        if mountpoint -q "$point"; then
            umount -v "$point"
        fi
    done
}

# Print a warning for good practices.
#
# Recommended practices is to set variables
# in front of `configure' or make(1), see:
#
# http://www.gnu.org/software/make/manual/html_node/Environment.html
# http://gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/Defining-Variables.html
# http://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/Setting-Output-Variables.html
warn_flags() {
    warn "" \
        "WARNING: Environment variable '$1' is set." \
        "This will be unset to avoid possible risks." \
        ""
    sleep 3
}

### Default values
BTCC="${BTCC:=gcc}"
BTCXX="${BTCXX:=g++}"
BTCFLAGS="${BTCFLAGS:=-O2}"
BTCXXFLAGS="${BTCFLAGS:=-O2}"
BTCPPFLAGS="${BTCPPFLAGS:=-P}"
BTLDFLAGS="${BTLDFLAGS:=}"
opt_keep=opt_keep.off
stage=0
arch="$(uname -m)" || chkstatus_or_exit
jobs=8
output="${worktree}/OUTPUT.${PROGRAM}"
TMPDIR="${TMPDIR:=${output}/sources}"
VENDOR="${VENDOR:=unknown}"

# Compose vendor name adding "-" as suffix
test -n "$VENDOR" && VENDOR="${VENDOR}-"

# Make sure unpack-files script is available
if test ! -x "${worktree_utils}/unpack-files"; then
    warn "${PROGRAM}: Required script 'unpack-files' not found"
    exit 1
else # Load the script as a alias
    alias unpack="${worktree_utils}/unpack-files"
    alias unpack-files="${worktree_utils}/unpack-files"
    alias unpack_files="${worktree_utils}/unpack-files"
    export -f unpack unpack-files unpack_files
fi

### Parse options
while getopts :ha:j:ko:s:V name; do
    case $name in
        h)
            usage
            exit 0
            ;;
        a)
            arch="$OPTARG"
            ;;
        j)
            jobs="$OPTARG"
            ;;
        k)
            opt_keep=opt_keep
            ;;
        o)
            output="$OPTARG"
            ;;
        s)
            stage="$OPTARG"
            ;;
        V)
            version
            exit 0
            ;;
        :)
            warn "Option '-${OPTARG}' requires an argument"
            usage
            exit 1
            ;;
        \?)
            warn "Illegal option -- '-${OPTARG}'"
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))
unset -f usage version

# Check for environment variables, print warning, unset in any case
test -n "$CC" && warn_flags CC
test -n "$CXX" && warn_flags CXX
test -n "$CFLAGS" && warn_flags CFLAGS
test -n "$CXXFLAGS" && warn_flags CXXFLAGS
test -n "$CPPFLAGS" && warn_flags CPPFLAGS
test -n "$LDFLAGS" && warn_flags LDFLAGS
unset CC CXX CFLAGS CXXFLAGS CPPFLAGS LDFLAGS warn_flags

# Load target architecture-file
if test -f "${worktree}/targets/$arch"; then
    echo "${PROGRAM}: Loading target $arch ..."
    . "${worktree}/targets/$arch"
else
    warn \
        "${PROGRAM}: Target name not recognized -- '${arch}'" \
        "See '$0 -h' for more information"
    exit 1
fi

# Set host variable if MACHTYPE is defined
if test -n "$MACHTYPE"; then
    host="$MACHTYPE"
fi

# Adjust 'host' for cross-compilation by renaming or appending to the VENDOR field
if test "$host" = "$target"; then
    # Rename VENDOR to 'cross'.  If empty, 'cross-linux' is added
    case "${host%-*-*}" in
        *-*)
            host="$(echo "$host" | sed -e 's/-[^-]*/-cross/')"
            ;;
        *)
            host="$(echo "$host" | sed -e 's/-[^-]*/-cross-linux/')"
            ;;
    esac
fi

# Compose variables for the physical output,
# printing some useful information
LFS="$output/${target}-sysroot"
LFS_TGT="$target"
LFS_HOST="$host"

# Print some useful information
printf '%s\n' \
    "BTCC: $BTCC" \
    "BTCXX: $BTCXX" \
    "BTCFLAGS: $BTCFLAGS" \
    "BTCXXFLAGS: $BTCXXFLAGS" \
    "BTLDFLAGS: $BTLDFLAGS" \
    "CPPFLAGS: $BTCPPFLAGS" \
    "Host: $host" \
    "Target: $target" \
    "Output directory: $output" \
    "LFS directory: $LFS"

# Remove write permission for group and other
umask 022

# Create required directories
mkdir -p -- "$output" "$TMPDIR"
chkstatus_or_exit

# Set default PATH, propagate variables
PATH="${LFS}/tools/bin:${PATH}"
CONFIG_SITE=$LFS/usr/share/config.site

export PATH VENDOR TMPDIR CONFIG_SITE

# Main loop
for file in ${worktree}/stages/${stage}/${@:-??-*}; do
    file="${file##*/}"
    done_file=".stage-${stage}-${file}.done"

    if test ! -f "${worktree}/stages/${stage}/$file"; then
        warn "${PROGRAM}: ${stage}/${file}: No such file or stage number"
        exit 1
    fi
    if test ! -x "${worktree}/stages/${stage}/$file"; then
        warn "${PROGRAM}: ${stage}/${file}: File not executable, dodging"
        continue
    fi

    ### Stage pre-settings

    # Create pre-settings for stage 0
    if test "$stage" = 0; then
        echo "Running pre-settings..."
    fi

    # Create pre-settings for stage 1
    if test "$stage" = 1; then
        echo "Running pre-settings..."
    fi

    # Create pre-settings for stage 2
    if test "$stage" = 2; then
        echo "Running pre-settings..."

        # Verify that to run this stage we must be root.
        if test "$(id -u)" -ne 0; then
            warn "${PROGRAM}: You must be root to run this stage"
            exit 1
        fi

        # Load the unpack-files script into the chroot environment
        cp -v "${worktree_utils}/unpack-files" "$LFS/bin"

        # Create needed directories if not already created
        mkdir -pv "$LFS"/{dev,proc,sys,run}

        # Setup permissions for the chroot environment
        chown -R root:root "$LFS"

        demount || chkstatus_or_exit

        # Mount the required filesystems for chroot
        mount -v --bind /dev "$LFS/dev"
        mount -vt devpts devpts "$LFS/dev/pts" -o gid=5,mode=620
        mount -vt proc proc "$LFS/proc"
        mount -vt sysfs sysfs "$LFS/sys"
        mount -vt tmpfs tmpfs "$LFS/run"
    fi

    # Check if the done file exists
    if test -f "${output}/${done_file}"; then
        echo "${PROGRAM}: Skipping $file from stages/${stage} ..."
        rm -rf "${TMPDIR}/*" || chkstatus_or_exit
        continue
    fi

    echo "${PROGRAM}: Processing $file from stages/${stage} ..."

    # Set trap before to run the script in order to
    # catch the return status, exit code 2 if fails
    trap 'chkstatus_or_exit 2' EXIT HUP INT QUIT ABRT TERM

    # Activate shell option(s)
    set -e +h

    # Clear hash table
    hash -r >/dev/null 2>&1 || true

    # If we are running stage 2, we need to run the scripts in a chroot
    if test "$stage" = 2; then
        # Pass in the stage2 scripts into bash with the chroot command
        chroot "$LFS" /usr/bin/env -i \
            HOME=/ \
            TERM="$TERM" \
            LC_ALL=POSIX \
            MAKEFLAGS="-j${jobs}" \
            PS1='(chroot)$ ' \
            PATH=/bin:/usr/bin:/sbin:/usr/sbin \
            /bin/bash < "${worktree}/stages/${stage}/$file" || demount
    else
        # Run the scripts as usual
        . "${worktree}/stages/${stage}/$file"
    fi

    # Deactivate shell option(s)
    set +e -h

    # Clear hash table
    hash -r >/dev/null 2>&1 || true

    # Reset given signals
    trap - EXIT HUP INT QUIT ABRT TERM

    # Create the done file
    touch "${output}/${done_file}"

    # Delete declared directories on the cleanup() function
    if test "$opt_keep" != opt_keep; then
        if type cleanup 1>/dev/null 2>/dev/null; then
            cleanup
            chkstatus_or_exit 2
            unset -f cleanup
        fi
    fi

    # Back to the current working directory
    cd -- "$worktree" || chkstatus_or_exit
done
